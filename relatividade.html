<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Curvatura do Espaço-Tempo – Campo Fraco</title>

<style>
body {
  margin: 0;
  display: flex;
  height: 100vh;
  background: radial-gradient(circle at center, #05060c, #02030a);
  color: #eaeaea;
  font-family: "Georgia", "Times New Roman", serif;
}

#controls {
  width: 300px;
  padding: 18px;
  background: rgba(0,0,0,0.6);
  border-right: 1px solid rgba(255,255,255,0.15);
}

h3 {
  font-weight: 400;
  letter-spacing: 0.08em;
}

label {
  display: block;
  margin-top: 14px;
  font-size: 14px;
}

input {
  width: 100%;
}

canvas {
  flex: 1;
}

.explanation {
  position: absolute;
  bottom: 0;
  left: 300px;
  right: 0;
  max-height: 42%;
  overflow-y: auto;
  background: rgba(0,0,0,0.75);
  padding: 24px;
  font-size: 15px;
  line-height: 1.8;
  border-top: 1px solid rgba(255,255,255,0.15);
}

.explanation h4 {
  margin-top: 20px;
  font-weight: 400;
  letter-spacing: 0.05em;
}

.equation {
  background: rgba(255,255,255,0.05);
  border-left: 3px solid #5aa0ff;
  padding: 12px;
  font-family: "Courier New", monospace;
  font-size: 14px;
  margin: 12px 0;
}

.source {
  font-size: 13px;
  opacity: 0.75;
}
</style>
</head>

<body>

<div id="controls">
  <h3>MODELO II · Parâmetros físicos</h3>

  <label>Massa
    <input type="range" id="mass" min="50" max="1000" value="300">
  </label>

  <label>Velocidade inicial X
    <input type="range" id="vx" min="-5" max="5" step="0.1" value="0">
  </label>

  <label>Velocidade inicial Y
    <input type="range" id="vy" min="-5" max="5" step="0.1" value="0">
  </label>

  <label>Escala da curvatura
    <input type="range" id="scale" min="40" max="260" value="120">
  </label>

  <p style="opacity:0.8;font-size:13px;">
    Clique para inserir massas no espaço-tempo.
  </p>
</div>

<canvas id="canvas"></canvas>

<section class="explanation">

<h4>1. O que esta malha representa</h4>

<p>
Esta visualização não é a Relatividade Geral completa. Ela representa o
<strong>limite de campo fraco</strong>, onde o potencial gravitacional Φ é pequeno
comparado a c². Nesse regime, a métrica do espaço-tempo pode ser aproximada.
</p>

<div class="equation">
Φ(r) = − G M / r
</div>

<p>
A malha se deforma porque estamos representando graficamente o valor escalar
do potencial gravitacional em cada ponto do espaço.
</p>

<h4>2. Relação com a Relatividade Geral</h4>

<p>
No limite de campo fraco, a métrica relativística assume a forma:
</p>

<div class="equation">
ds² ≈ − (1 + 2Φ/c²) c² dt² + (1 − 2Φ/c²)(dx² + dy² + dz²)
</div>

<p>
Aqui ocorre algo crucial. O potencial gravitacional aparece diretamente no
<strong>termo temporal</strong> da métrica. Isso significa que o tempo passa mais devagar
próximo a massas.
</p>

<h4>3. Tempo gravitacional</h4>

<p>
A dilatação do tempo gravitacional pode ser escrita como:
</p>

<div class="equation">
Δt₀ = Δt · √(1 + 2Φ/c²)
</div>

<p>
Nesta simulação, a profundidade da malha representa indiretamente essa
dilatação temporal. Quanto mais profunda a curvatura, mais lento o tempo local.
</p>

<h4>4. Movimento dos corpos</h4>

<p>
As massas se movem seguindo gradientes do potencial, o que no limite clássico
equivale à força gravitacional de Newton. Em Relatividade Geral, esse movimento
é interpretado como geodésicas do espaço-tempo.
</p>

<h4>5. Proporção física</h4>

<p>
O raio visual de cada corpo é proporcional à raiz cúbica da massa, refletindo
a relação entre volume e massa em densidade aproximadamente constante.
</p>

<h4>Referências</h4>

<p class="source">
Einstein, A. Relativity: The Special and the General Theory.  
Misner, Thorne & Wheeler. Gravitation.  
Carroll, S. Spacetime and Geometry.  
Hartle, J. Gravity.
</p>

</section>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth - 300;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

const G = 0.6;
const dt = 0.08;

let bodies = [];

const massSlider = document.getElementById("mass");
const vxSlider = document.getElementById("vx");
const vySlider = document.getElementById("vy");
const scaleSlider = document.getElementById("scale");

function potential(x, y) {
  let phi = 0;
  for (let b of bodies) {
    const dx = x - b.x;
    const dy = y - b.y;
    const r = Math.sqrt(dx*dx + dy*dy) + 10;
    phi -= G * b.m / r;
  }
  return phi;
}

function updatePhysics() {
  for (let i = 0; i < bodies.length; i++) {
    let ax = 0;
    let ay = 0;

    for (let j = 0; j < bodies.length; j++) {
      if (i === j) continue;

      const dx = bodies[j].x - bodies[i].x;
      const dy = bodies[j].y - bodies[i].y;
      const r2 = dx*dx + dy*dy + 25;
      const r = Math.sqrt(r2);

      const a = G * bodies[j].m / r2;
      ax += a * dx / r;
      ay += a * dy / r;
    }

    bodies[i].vx += ax * dt;
    bodies[i].vy += ay * dt;
  }

  for (let b of bodies) {
    b.x += b.vx * dt;
    b.y += b.vy * dt;
  }
}

function drawGrid() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const step = 32;
  const scale = scaleSlider.value;
  const alpha = 0.25;
  const beta = 0.45;

  function project(x,y,z){
    return { x: x + alpha*z, y: y - beta*z };
  }

  ctx.strokeStyle = "rgba(200,200,255,0.25)";
  ctx.lineWidth = 1;

  for (let x=0; x<canvas.width; x+=step){
    ctx.beginPath();
    let first=true;
    for (let y=0; y<canvas.height; y+=step){
      const z = -Math.log(1 + Math.abs(potential(x,y))) * scale;
      const p = project(x,y,z);
      if(first){ctx.moveTo(p.x,p.y); first=false;}
      else ctx.lineTo(p.x,p.y);
    }
    ctx.stroke();
  }

  for (let y=0; y<canvas.height; y+=step){
    ctx.beginPath();
    let first=true;
    for (let x=0; x<canvas.width; x+=step){
      const z = -Math.log(1 + Math.abs(potential(x,y))) * scale;
      const p = project(x,y,z);
      if(first){ctx.moveTo(p.x,p.y); first=false;}
      else ctx.lineTo(p.x,p.y);
    }
    ctx.stroke();
  }

  for (let b of bodies){
    const radius = Math.cbrt(b.m) * 0.9;
    ctx.beginPath();
    ctx.arc(b.x, b.y, radius, 0, Math.PI*2);
    ctx.fillStyle = "#ffffff";
    ctx.fill();
  }
}

canvas.addEventListener("click", e=>{
  const r = canvas.getBoundingClientRect();
  bodies.push({
    x: e.clientX - r.left,
    y: e.clientY - r.top,
    vx: parseFloat(vxSlider.value),
    vy: parseFloat(vySlider.value),
    m: parseFloat(massSlider.value)
  });
});

function loop(){
  updatePhysics();
  drawGrid();
  requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
